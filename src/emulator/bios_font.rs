use super::Emulator;

impl Emulator {
    /// Load a built-in font to VRAM, emulating what the PCE BIOS does at power-on.
    /// The font covers ASCII 0x20-0x7F (96 characters), loaded at tile 0x100+ascii
    /// (VRAM word addresses 0x1000 + ascii * 16).
    pub(crate) fn load_bios_font(&mut self) {
        // 8×8 1bpp font data for ASCII 0x20–0x7F (96 characters, 8 bytes each).
        // Extracted from PCE System Card 3.0 BIOS ROM (offset 0x02100).
        // Positions 0x40 and 0x5C are overridden for HuCard game compatibility:
        //   0x40: blank (games use this tile as space; BIOS '@' would show otherwise)
        //   0x5C: kept as BIOS '¥' (yen sign, standard for Japanese systems)
        #[rustfmt::skip]
        const FONT_8X8: [[u8; 8]; 96] = [
            [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00], // 0x20 ' '
            [0x10,0x38,0x38,0x38,0x10,0x10,0x00,0x10], // 0x21 '!'
            [0x00,0x14,0x14,0x00,0x00,0x00,0x00,0x00], // 0x22 '"'
            [0x24,0x26,0x3C,0x66,0x3C,0x64,0x24,0x00], // 0x23 '#'
            [0x10,0x7C,0xD0,0x7C,0x16,0x96,0x7C,0x10], // 0x24 '$'
            [0x00,0x42,0xA4,0x48,0x12,0x25,0x42,0x00], // 0x25 '%'
            [0x30,0x48,0x48,0x39,0x46,0x44,0x3B,0x00], // 0x26 '&'
            [0x00,0x02,0x06,0x04,0x00,0x00,0x00,0x00], // 0x27 '\''
            [0x04,0x08,0x10,0x10,0x10,0x08,0x04,0x00], // 0x28 '('
            [0x20,0x10,0x08,0x08,0x08,0x10,0x20,0x00], // 0x29 ')'
            [0x00,0x00,0x10,0x54,0x38,0x54,0x10,0x00], // 0x2A '*'
            [0x00,0x00,0x10,0x10,0x7C,0x10,0x10,0x00], // 0x2B '+'
            [0x00,0x00,0x00,0x00,0x06,0x06,0x02,0x04], // 0x2C ','
            [0x00,0x00,0x00,0x00,0x7C,0x00,0x00,0x00], // 0x2D '-'
            [0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00], // 0x2E '.'
            [0x00,0x02,0x04,0x08,0x10,0x20,0x40,0x00], // 0x2F '/'
            [0x38,0x4C,0xC6,0xC6,0xC6,0x64,0x38,0x00], // 0x30 '0'
            [0x18,0x38,0x18,0x18,0x18,0x18,0x7E,0x00], // 0x31 '1'
            [0x7C,0xC6,0x0E,0x3C,0x78,0xE0,0xFE,0x00], // 0x32 '2'
            [0x7E,0x0C,0x18,0x3C,0x06,0xC6,0x7C,0x00], // 0x33 '3'
            [0x1C,0x3C,0x6C,0xCC,0xFE,0x0C,0x0C,0x00], // 0x34 '4'
            [0xFC,0xC0,0xFC,0x06,0x06,0xC6,0x7C,0x00], // 0x35 '5'
            [0x3C,0x60,0xC0,0xFC,0xC6,0xC6,0x7C,0x00], // 0x36 '6'
            [0xFE,0xC6,0x0C,0x18,0x30,0x30,0x30,0x00], // 0x37 '7'
            [0x78,0xC4,0xE4,0x78,0x86,0x86,0x7C,0x00], // 0x38 '8'
            [0x7C,0xC6,0xC6,0x7E,0x06,0x0C,0x78,0x00], // 0x39 '9'
            [0x00,0x30,0x30,0x00,0x30,0x30,0x00,0x00], // 0x3A ':'
            [0x00,0x30,0x30,0x00,0x30,0x30,0x10,0x20], // 0x3B ';'
            [0x00,0x00,0x0C,0x30,0x40,0x30,0x0C,0x00], // 0x3C '<'
            [0x3C,0x42,0x99,0xA1,0xA1,0x99,0x42,0x3C], // 0x3D '©' (HuCard BIOS maps '=' to ©)
            [0x00,0x00,0x60,0x18,0x04,0x18,0x60,0x00], // 0x3E '>'
            [0x7C,0xC6,0xC6,0x1C,0x10,0x10,0x00,0x10], // 0x3F '?'
            [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00], // 0x40 ' ' (blank for HuCard space tile)
            [0x38,0x64,0xC2,0xC2,0xFE,0xC2,0xC2,0x00], // 0x41 'A'
            [0xFC,0xC2,0xC2,0xFC,0xC2,0xC2,0xFC,0x00], // 0x42 'B'
            [0x3C,0x62,0xC0,0xC0,0xC0,0x62,0x3C,0x00], // 0x43 'C'
            [0xF8,0xC4,0xC2,0xC2,0xC2,0xC4,0xF8,0x00], // 0x44 'D'
            [0xFE,0xC0,0xC0,0xFC,0xC0,0xC0,0xFE,0x00], // 0x45 'E'
            [0xFE,0xC0,0xC0,0xFC,0xC0,0xC0,0xC0,0x00], // 0x46 'F'
            [0x3E,0x60,0xC0,0xCE,0xC2,0x62,0x3E,0x00], // 0x47 'G'
            [0xC2,0xC2,0xC2,0xFE,0xC2,0xC2,0xC2,0x00], // 0x48 'H'
            [0x7E,0x18,0x18,0x18,0x18,0x18,0x7E,0x00], // 0x49 'I'
            [0x1E,0x06,0x06,0x06,0x86,0x86,0x7C,0x00], // 0x4A 'J'
            [0xC6,0xC4,0xC8,0xD0,0xE8,0xC4,0xC2,0x00], // 0x4B 'K'
            [0x60,0x60,0x60,0x60,0x60,0x60,0x7E,0x00], // 0x4C 'L'
            [0xC2,0xC6,0xEA,0xD2,0xC2,0xC2,0xC2,0x00], // 0x4D 'M' (was 0xEE→0xC6, 0xD6→0xD2)
            [0xC2,0xC2,0xE2,0xD2,0xCA,0xC6,0xC2,0x00], // 0x4E 'N'
            [0x7C,0xC2,0xC2,0xC2,0xC2,0xC2,0x7C,0x00], // 0x4F 'O'
            [0xFC,0xC2,0xC2,0xC2,0xFC,0xC0,0xC0,0x00], // 0x50 'P'
            [0x7C,0xC2,0xC2,0xC2,0xDA,0xC4,0x7A,0x00], // 0x51 'Q'
            [0xFC,0xC2,0xC2,0xC2,0xFC,0xC4,0xC2,0x00], // 0x52 'R'
            [0x7C,0xC2,0xC0,0x7C,0x02,0xC2,0x7C,0x00], // 0x53 'S'
            [0x7E,0x18,0x18,0x18,0x18,0x18,0x18,0x00], // 0x54 'T'
            [0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0x7C,0x00], // 0x55 'U'
            [0xC2,0xC2,0xC2,0xE2,0x74,0x38,0x10,0x00], // 0x56 'V'
            [0xC2,0xC2,0xC2,0xD2,0xEA,0xC6,0xC2,0x00], // 0x57 'W'
            [0xC2,0xE6,0x7C,0x38,0x7C,0xE6,0xC2,0x00], // 0x58 'X'
            [0x62,0x62,0x62,0x34,0x18,0x18,0x18,0x00], // 0x59 'Y'
            [0xFE,0x0E,0x1C,0x38,0x70,0xE0,0xFE,0x00], // 0x5A 'Z'
            [0x18,0x10,0x10,0x10,0x10,0x10,0x18,0x00], // 0x5B '['
            [0x10,0x38,0x38,0x38,0x10,0x10,0x00,0x10], // 0x5C '!' (HuCard BIOS maps '\' to !)
            [0x18,0x08,0x08,0x08,0x08,0x08,0x18,0x00], // 0x5D ']'
            [0x00,0x00,0x10,0x28,0x28,0x44,0x44,0x00], // 0x5E '^'
            [0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00], // 0x5F '_'
            [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00], // 0x60 '`'
            [0x00,0x00,0x38,0x04,0x3C,0x64,0x3A,0x00], // 0x61 'a'
            [0x20,0x20,0x20,0x38,0x24,0x24,0x38,0x00], // 0x62 'b'
            [0x00,0x00,0x18,0x24,0x20,0x24,0x18,0x00], // 0x63 'c'
            [0x04,0x04,0x04,0x1C,0x24,0x24,0x1C,0x00], // 0x64 'd'
            [0x00,0x00,0x18,0x24,0x3C,0x20,0x1C,0x00], // 0x65 'e'
            [0x18,0x26,0x20,0x78,0x20,0x20,0x20,0x00], // 0x66 'f'
            [0x00,0x00,0x1A,0x24,0x24,0x1C,0x04,0x38], // 0x67 'g'
            [0x20,0x20,0x20,0x38,0x24,0x24,0x24,0x00], // 0x68 'h'
            [0x00,0x00,0x10,0x00,0x10,0x10,0x10,0x00], // 0x69 'i'
            [0x00,0x00,0x04,0x00,0x04,0x04,0x24,0x18], // 0x6A 'j'
            [0x20,0x20,0x20,0x24,0x28,0x38,0x24,0x00], // 0x6B 'k'
            [0x30,0x10,0x10,0x10,0x10,0x10,0x10,0x00], // 0x6C 'l'
            [0x00,0x00,0x54,0x2A,0x2A,0x2A,0x2A,0x00], // 0x6D 'm'
            [0x00,0x00,0x58,0x24,0x24,0x24,0x24,0x00], // 0x6E 'n'
            [0x00,0x00,0x18,0x24,0x24,0x24,0x18,0x00], // 0x6F 'o'
            [0x00,0x00,0x38,0x24,0x24,0x38,0x20,0x20], // 0x70 'p'
            [0x00,0x00,0x1C,0x24,0x24,0x1C,0x04,0x04], // 0x71 'q'
            [0x00,0x00,0x20,0x2C,0x30,0x20,0x20,0x00], // 0x72 'r'
            [0x00,0x00,0x1C,0x20,0x3C,0x04,0x38,0x00], // 0x73 's'
            [0x00,0x20,0x20,0x78,0x20,0x24,0x18,0x00], // 0x74 't'
            [0x00,0x00,0x24,0x24,0x24,0x24,0x18,0x00], // 0x75 'u'
            [0x00,0x00,0x24,0x24,0x28,0x30,0x20,0x00], // 0x76 'v'
            [0x00,0x00,0x44,0x54,0x54,0x54,0x28,0x00], // 0x77 'w'
            [0x00,0x00,0x24,0x18,0x18,0x18,0x24,0x00], // 0x78 'x'
            [0x00,0x00,0x24,0x24,0x24,0x1C,0x04,0x18], // 0x79 'y'
            [0x00,0x00,0x7C,0x0C,0x18,0x30,0x7C,0x00], // 0x7A 'z'
            [0x08,0x10,0x10,0x20,0x10,0x10,0x08,0x00], // 0x7B '{'
            [0x08,0x08,0x00,0x00,0x00,0x08,0x08,0x00], // 0x7C '|'
            [0x10,0x08,0x08,0x04,0x08,0x08,0x10,0x00], // 0x7D '}'
            [0x00,0x00,0x00,0x32,0x4C,0x00,0x00,0x00], // 0x7E '~'
            [0x81,0x42,0x24,0x18,0x18,0x24,0x42,0x81], // 0x7F DEL
        ];

        // Load font to VRAM at tile 0x100 + ascii_code.
        // Each tile = 16 VRAM words. Set all 4 bitplanes so font pixels have
        // value 0xF (palette entry 15), which is typically white in text palettes.
        //   word[row]   = (bitmap << 8) | bitmap   (planes 0 & 1)
        //   word[row+8] = (bitmap << 8) | bitmap   (planes 2 & 3)
        for (i, glyph) in FONT_8X8.iter().enumerate() {
            let ascii = 0x20 + i;
            let tile_id = 0x100 + ascii;
            let base_addr = (tile_id * 16) as u16;
            for row in 0..8 {
                let bits = glyph[row] as u16;
                let word = (bits << 8) | bits; // plane 0 = plane 1 = font bitmap
                self.bus.vdc_write_vram_direct(base_addr + row as u16, word);
                // planes 2 & 3 = same font bitmap
                self.bus
                    .vdc_write_vram_direct(base_addr + 8 + row as u16, word);
            }
        }
    }
}
